import numpy as np
import scipy.stats as stats
# Даны значения величины заработной платы заемщиков банка (zp) и значения их поведенческого кредитного скоринга (ks): 
# zp = [35, 45, 190, 200, 40, 70, 54, 150, 120, 110], 
# ks = [401, 574, 874, 919, 459, 739, 653, 902, 746, 832]. 
# 1. Используя математические операции, посчитать коэффициенты линейной регрессии, 
# приняв за X заработную плату (то есть, zp - признак), а за y - значения скорингового балла 
# (то есть, ks - целевая переменная). Произвести расчет как с использованием intercept, так и без.

# формула интерсепта: b0 = (∑Y * ∑X^2 - ∑X * ∑X*Y)/(n * ∑(X^2) - (∑X)^2)
zp = np.array([35, 45, 190, 200, 40, 70, 54, 150, 120, 110])
ks = np.array([401, 574, 874, 919, 459, 739, 653, 902, 746, 832])
Xsum = sum(zp) #1014
Ysum = sum(ks) # 7099
XsquaredSum = sum(zp**2) # 137766
XYprodSum = sum(zp*ks) # 811417
print(Xsum, Ysum, XsquaredSum, XYprodSum)
n = 10
b0 = (Ysum*XsquaredSum - Xsum*XYprodSum)/(n*XsquaredSum - Xsum**2) 
print(b0) # 444.1773573243596
# формула b1: b1 = (n * ∑X*Y - ∑X * ∑Y)/(n * ∑(X^2) - (∑X)^2)
b1 = (n*XYprodSum - Xsum*Ysum)/(n*XsquaredSum-Xsum**2)
print(b1) # 2.6205388824027653

# 2. Посчитать коэффициент линейной регрессии при заработной плате (zp), 
# используя градиентный спуск (без intercept): y = b1*X
Y_pred = b0 + b1 * zp # [535.89621821, 562.10160703, 942.07974498, 968.2851338,  548.99891262, 627.61507909, 585.68645697, 837.25818968, 758.64202321, 732.43663439]
mse = ((ks - Y_pred)**2).sum()/2 # средняя квадратичная ошибка 
print(mse) # 32352.071005883292
def mse_(b1, y = zp, x = ks, n = 10):
    return np.sum((b1*x - y)**2) / n
b1 = 0.1
alpha = 1e-6
for i in range(1500):
    b1 -= alpha*(2/n)*np.sum((b1*zp-ks)*zp)
    if i % 100 == 0:
        print('Iteration = {i}, b1 = {b1}, mse = {mse}'.format(i=i,b1=b1,mse=mse_(b1)))
 # Iteration = 1100, b1 = 5.889820420132437, mse = 17597217.437721707 
 #-  начиная с итерации 1100, значения b1 и mse не изменяются    
                                 